TITLE POLINOM
;Программа вычисления полинома вида Y=a1*X^n+a2*X^(n-1)+...+an*X+an+1
;Входные параметры:
;коэффиценты полинома ai в массиве MAS_A
;порядок полинома N
;аргумент полинома X
;Выходные параметры: 
;вычисленное значение полинома Y
;сообщения MES_1, MES_2, MES_3
.MODEL SMALL	;Модель памяти ближнего типа
.DATA	;Открыть сегмент данных
	MAS_A DW -3, 9, 5, 1, 2	;Коэффиценты полинома
	N DW 4	;Порядок полинома равен 4
	X DW 10	;Аргумент полинома равен 10
	Y DW (?)	;Результат вычисления полинома
	MES_1 DB 'Overflow', 13, 10, '$'	;Сообщение MES_1
	MES_2 DB 'Result minus', 13, 10, '$'	;Сообщение MES_2
	MES_3 DB 'Result plus', 13, 10, '$'	;Сообщение MES_3
	MES_Y DB 'Y=-3*10^4+9*10^3+5*10^2+1*10^1+2*10^0 = $'	;Строка с полиномом
	Sign DB (?)	;Переменная для хранения знака числа
	Y_ASCII DB 7 DUP(?)	;Переменная для хранения символов ASCII
.STACK 100h	;Отвести под стек 256 байт
.CODE	;Открыть сегмент кодов
Preobr PROC	;Начать процедуру с именем Preobr
	mov AX, BX	;Переместить в AX значние BX
	mov Sign, ' '	;Поместить в переменную знака символ пробела (знак +)
	cmp AX, 0	;Сравнить число с нулём
	jns M_1	;Если больше или равно 0, перейти на метку M_1
	mov Sign, '-'	;иначе поместить в переменную знака символ минус (знак -)
	neg AX	;Преобразовать в прямой код
M_1:
	xor CX, CX	;Очистить CX
	mov BX, 10	;Поместить в BX делитель равный 10
M_2:
	xor DX, DX	;Очистить DX
	div BX	;Разделить число на 10
	push DX	;Сохранить остаток в стеке
	inc CX	;Увеличить значение CX на единицу
	cmp AX, 0	;Сравнить число с нулём
	jne M_2	;Если больше или равно 0, повторить деление
	xor SI, SI	;Очистить SI
	mov AL, Sign	;Загрузить в AL знак числа
	mov Y_ASCII[SI], AL	;Переслать знак в Y_ASCII
	inc SI	;Увеличить SI на единицу
M_3:
	pop AX	;Извлечь содержимое стека в AX
	add AL, 30h	;Вычислить ASCII код для цифры
	mov Y_ASCII[SI], AL	;Переслеать ASCII код в Y_ASCII
	inc SI	;Увеличить SI на единицу
	loop M_3	;Если содержимое CX не 0, повторить цикл
	mov Y_ASCII[SI], '$'	;Поместить символ конца строки в Y_ASCII
	ret	;Возврат из процедуры
Preobr ENDP	;Закончить процедуру с именем Preobr

Output PROC	;Начать процедуру с именем Output
	mov DX, BX	;Вывести на экран
	mov AH, 09	;строку, смещение которой находится в регистре BX,
	int 21h	;с помощью DOS
	ret	;Возврат из процедуры
Output ENDP	;Закончить процедуру с именем Output

Polinom PROC	;Начать процедуру с именем Polinom
	lea SI, MAS_A	;Загрузить в SI начальный адрес массива MAS_A
	mov CX, N	;Поместить в CX значение переменной N
	xor DX, DX	;Очистить регистр DX
	mov AX, [SI]	;Поместить в AX первый элемент элемент массива
	mov BX, offset MES_1	;Поместить в BX смещение строки MES_2
M:
	imul X	;Умножить значение в регистре AX на значение переменной X
	jo Result	;При условии переполнения перейти к метке Result
	inc SI	;Увеличение индекса
	inc SI	;на 2
	add AX, [SI]	;Добавить к значению AX элемент массива
	jo Result	;При условии переполнения перейти к метке Result
	loop M	;Уменьшить значение CX на 1, перейти к метке M, если значение CX не равно 0
	mov Y, AX	;Поместить значение AX в переменную Y
	cmp AX, 0	;Сравнить AX с 0
	mov BX, offset MES_3	;Если AX больше нуля поместить в BX смещение строки MES_3
	jge Result	;и перейти к метке Result
	mov BX, offset MES_2	;Иначе - поместить в BX смещение строки MES_2
	jmp Result	;и перейти к метке Result
Result:
	ret
Polinom ENDP	;Закончить процедуру с именем Polinom

Start:
	mov AX, @DATA	;Инициалищировать
	mov DS, AX	;сегментный регистр DS
	call Polinom	;Вызвать процедуру Polinom
	call Output	;Вызвать процедуру Output
	mov BX, offset MES_Y	;Поместить в BX смещение строки MES_Y
	call Output	;Вызвать процедуру Output
	mov BX, Y	;Поместить в BX значение переменной Y
	call Preobr	;Вызвать функцию преобразования числа в BX в символьный вид
	mov BX, offset Y_ASCII	;Поместить в BX смещение строки Y_ASCII
	call Output	;Вызвать процедуру Output
	mov AL, 0	;Завершить
	mov AH, 4Ch	;программу
	int 21h	;с помощью DOS
END Start	;Конец исходного модуля