TITLE POLINOM
;Программа вычисления полинома вида Y=a1*X^n+a2*X^(n-1)+...+an*X+an+1
;Входные параметры:
;коэффиценты полинома ai в массиве MAS_A
;порядок полинома N
;аргумент полинома X
;Выходные параметры: 
;вычисленное значение полинома Y
;сообщения MES_1, MES_2, MES_3
.MODEL SMALL	;Модель памяти ближнего типа
.DATA	;Открыть сегмент данных
	MAS_A DW -3, 3, -6, 9, -20	;Коэффиценты полинома
	N DW 4	;Порядок полинома равен 4
	X DW 10	;Аргумент полинома равен 10
	Y DW (?)	;Результат вычисления полинома
	MES_1 DB 'Overflow', 13, 10, '$'	;Сообщение MES_1
	MES_2 DB 'Result minus', 13, 10, '$'	;Сообщение MES_2
	MES_3 DB 'Result plus', 13, 10, '$'	;Сообщение MES_3
.STACK 100h	;Отвести под стек 256 байт
.Code	;Открыть сегмент кодов
Start:
	mov AX, @DATA	;Инициалищировать
	mov DS, AX	;сегментный регистр DS
	lea SI, MAS_A	;Загрузить в SI начальный адрес массива MAS_A
	mov CX, N	;Поместить в CX значение переменной N
	xor DX, DX	;Очистить регистр DX
	mov AX, [SI]	;Поместить в AX первый элемент элемент массива
M_1:
	imul X	;Умножить значение в регистре AX на значение переменной X
	jo mes1	;При условии переполнения перейти к метке mes1
	inc SI	;Увеличение индекса
	inc SI	;на 2
	add AX, [SI]	;Добавить к значению AX элемент массива
	jo mes1	;При условии переполнения перейти к метке mes1
	loop M_1	;Уменьшить значение CX на 1, перейти к метке M_1, если значение CX не равно 0
	mov Y, AX	;Поместить значение AX в переменную Y
	cmp AX, 0	;Сравнить AX с 0
	jge mes3	;Если AX больше нуля перейти к mes3
	mov DX, offset MES_2	;Вывести на экран
	mov AH, 09	;сообщение MES_2
	int 21h	;с помощью DOS
Exit:
	mov AL, 0	;Завершить
	mov AH, 4Ch	;программу
	int 21h	;с помощью DOS
mes1:
	mov DX, offset MES_1	;Вывести на экран
	mov AH, 09	;сообщение MES_1
	int 21h	;с помощью DOS
	jmp Exit	;Перейти к метке Exit
mes3:
	mov DX, offset MES_3	;Вывести на экран
	mov AH, 09	;сообщение MES_3
	int 21h	;с помощью DOS
	jmp Exit	;Перейти к метке Exit
END Start	;Конец исходного модуля